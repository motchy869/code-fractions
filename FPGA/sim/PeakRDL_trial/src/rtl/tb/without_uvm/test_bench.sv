// Verible directive
// verilog_lint: waive-start parameter-name-style
// verilog_lint: waive-start line-length

`include "../../my_mod.svh"

`default_nettype none

// timescale is defined in Makefile.

//! A test bench for CSR generated by PeakRDL.
module test_bench;
// ---------- parameters ----------
localparam int CLK_PERIOD_NS = 8; //! clock period in ns
localparam int SIM_TIME_LIMIT_NS = 1500; //! simulation time limit in ns
//! Reset signal deasserts right after this clock rising-edge.
//!
//! 'Holding AXI ARESETN asserted for 16 cycles of the slowest AXI clock is generally a sufficient reset pulse width for Xilinx IP. --UG1037.' (AXI VIP message)
localparam int RELEASE_RST_AFTER_CLK = 20;

localparam int CSR_ADDR_SPACE_SIZE_BYTE = 'h40; //! size of CSR address space in byte
localparam int AXI4_LITE_ADDR_BIT_WIDTH = $clog2(CSR_ADDR_SPACE_SIZE_BYTE); //! bit width of AXI4-Lite address bus
localparam int AXI4_LITE_DATA_BIT_WIDTH = 32; //! bit width of AXI4-Lite data bus
// --------------------

// ---------- internal signal and storage ----------
var bit r_clk; //! clock signal
var bit r_sync_rst; //! clock synchronous reset signal

//! AXI4-Lite virtual interface between test bench and DUT
virtual interface axi4_lite_if #(
    .ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
    .DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
) axi4_lite_vif_0;
// --------------------

// ---------- instances ----------
//! AXI4-Lite interface for DUT.
axi4_lite_if #(
    .ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
    .DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
) axi4_lite_if_0 (
    .i_clk(r_clk)
);

//! DUT instance
my_mod my_mod_0 (
    .i_clk(r_clk),
    .i_sync_rst(r_sync_rst),
    .if_s_axi4_lite(axi4_lite_if_0.slv_port)
);
// --------------------

//! Drive the clock.
initial forever #(CLK_PERIOD_NS/2) r_clk = ~r_clk;

//! Drive the reset signal.
task automatic drive_rst();
    r_sync_rst <= 1'b1;
    repeat (RELEASE_RST_AFTER_CLK) begin
        @(posedge r_clk);
    end
    r_sync_rst <= 1'b0;
endtask

task automatic csr_check();
    const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] MY_MOD_VERSION_ADDR = AXI4_LITE_ADDR_BIT_WIDTH'('h0);
    const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] PROTECTED_REG_ADDR = AXI4_LITE_ADDR_BIT_WIDTH'('h4);
    const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] UNLOCK_PROTECTED_REG_ADDR = AXI4_LITE_ADDR_BIT_WIDTH'('h8);
    const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] SINGLE_PULSE_ADDR = AXI4_LITE_ADDR_BIT_WIDTH'('hC);
    const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] WRITE_ONCE_ADDR = AXI4_LITE_ADDR_BIT_WIDTH'('h10);
    const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] SIMPLE_MEM_ADDR = AXI4_LITE_ADDR_BIT_WIDTH'('h20);

    var bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] read_back_data;
    axi4_lite_if_pkg::axi4_resp_t resp;

    begin // MY_MOD_VERSION
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] expected_rd_data = AXI4_LITE_DATA_BIT_WIDTH'('h01234567);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_read(axi4_lite_vif_0, MY_MOD_VERSION_ADDR, read_back_data, resp);

        assert(read_back_data == expected_rd_data) else begin
            $fatal(2, "MY_MOD_VERSION: read data mismatch.");
        end
    end

    begin // PROTECTED_REG
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] unlock_key = '1;
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] expected_rd_data_0 = AXI4_LITE_DATA_BIT_WIDTH'('h0); // expected read data before unlock
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] expected_rd_data_1 = AXI4_LITE_DATA_BIT_WIDTH'('hC001C0DE); // expected read data after unlock

        // before unlock
        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_write(axi4_lite_vif_0, PROTECTED_REG_ADDR, AXI4_LITE_DATA_BIT_WIDTH'('hBADCACA0), '1, resp);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_read(axi4_lite_vif_0, PROTECTED_REG_ADDR, read_back_data, resp);

        assert(read_back_data == expected_rd_data_0) else begin
            $fatal(2, "PROTECTED_REG: read data mismatch.");
        end

        // unlock
        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_write(axi4_lite_vif_0, UNLOCK_PROTECTED_REG_ADDR, unlock_key, '1, resp);

        // after unlock
        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_write(axi4_lite_vif_0, PROTECTED_REG_ADDR, expected_rd_data_1, '1, resp);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_read(axi4_lite_vif_0, PROTECTED_REG_ADDR, read_back_data, resp);

        assert(read_back_data == expected_rd_data_1) else begin
            $fatal(2, "PROTECTED_REG: read data mismatch.");
        end
    end

    begin // SINGLE_PULSE
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] expected_rd_data = AXI4_LITE_DATA_BIT_WIDTH'('h0);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_write(axi4_lite_vif_0, SINGLE_PULSE_ADDR, AXI4_LITE_DATA_BIT_WIDTH'('h1), '1, resp);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_read(axi4_lite_vif_0, SINGLE_PULSE_ADDR, read_back_data, resp);

        assert(read_back_data == expected_rd_data) else begin
            $fatal(2, "SINGLE_PULSE: read data mismatch.");
        end
    end

    begin // WRITE_ONCE
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] expected_rd_data = AXI4_LITE_DATA_BIT_WIDTH'('hC001FACE);
        const bit [AXI4_LITE_DATA_BIT_WIDTH-1:0] wr_data_2nd = AXI4_LITE_DATA_BIT_WIDTH'('hCAFEBABE);

        // 1 st write
        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_write(axi4_lite_vif_0, WRITE_ONCE_ADDR, expected_rd_data, '1, resp);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_read(axi4_lite_vif_0, WRITE_ONCE_ADDR, read_back_data, resp);

        assert(read_back_data == expected_rd_data) else begin
            $fatal(2, "WRITE_ONCE: read data mismatch.");
        end

        // 2nd write
        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_write(axi4_lite_vif_0, WRITE_ONCE_ADDR, wr_data_2nd, '1, resp);

        axi4_lite_if_pkg::axi4_lite_access#(
            .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
            .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
        )::axi4_lite_read(axi4_lite_vif_0, WRITE_ONCE_ADDR, read_back_data, resp);

        assert(read_back_data == expected_rd_data) else begin
            //$fatal(2, "WRITE_ONCE: read data mismatch."); // `w1` and `rw1` has not been supported yet.
        end
    end

    begin // SIMPLE_MEM
        // write
        for (int i=0; i<my_mod.RAM_DEPTH; ++i) begin
            const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] byte_addr = SIMPLE_MEM_ADDR + AXI4_LITE_ADDR_BIT_WIDTH'(i*my_mod.BYTES_PER_WORD);
            axi4_lite_if_pkg::axi4_lite_access#(
                .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
                .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
            )::axi4_lite_write(axi4_lite_vif_0, byte_addr, AXI4_LITE_DATA_BIT_WIDTH'(i), '1, resp);
        end

        // read
        for (int i=0; i<my_mod.RAM_DEPTH; ++i) begin
            const bit [AXI4_LITE_ADDR_BIT_WIDTH-1:0] byte_addr = SIMPLE_MEM_ADDR + AXI4_LITE_ADDR_BIT_WIDTH'(i*my_mod.BYTES_PER_WORD);
            axi4_lite_if_pkg::axi4_lite_access#(
                .AXI4_LITE_ADDR_BIT_WIDTH(AXI4_LITE_ADDR_BIT_WIDTH),
                .AXI4_LITE_DATA_BIT_WIDTH(AXI4_LITE_DATA_BIT_WIDTH)
            )::axi4_lite_read(axi4_lite_vif_0, byte_addr, read_back_data, resp);

            assert(read_back_data == AXI4_LITE_DATA_BIT_WIDTH'(i)) else begin
                $fatal(2, "SIMPLE_MEM: read data mismatch.");
            end
        end
    end
endtask

task automatic scenario();
    drive_rst();
    @(posedge r_clk);
    csr_check();
    @(posedge r_clk);
    $finish;
endtask

//! Launch scenario and manage time limit.
initial begin
    axi4_lite_vif_0 = axi4_lite_if_0;
    axi4_lite_vif_0.reset_mst_out_sigs();
    fork
        scenario();
    join_none
    #SIM_TIME_LIMIT_NS;
    $fatal(2, "Simulation timeout.");
end

endmodule

`default_nettype wire
