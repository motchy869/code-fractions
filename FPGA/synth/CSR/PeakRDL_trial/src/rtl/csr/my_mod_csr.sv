// Verible directive
// verilog_lint: waive-start line-length
// verilog_lint: waive-start typedef-structs-unions

`include "my_mod_csr_pkg.svh"

// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module my_mod_csr (
        input wire clk,
        input wire rst,

        output logic s_axi4lite_awready,
        input wire s_axi4lite_awvalid,
        input wire [5:0] s_axi4lite_awaddr,
        input wire [2:0] s_axi4lite_awprot,
        output logic s_axi4lite_wready,
        input wire s_axi4lite_wvalid,
        input wire [31:0] s_axi4lite_wdata,
        input wire [3:0]s_axi4lite_wstrb,
        input wire s_axi4lite_bready,
        output logic s_axi4lite_bvalid,
        output logic [1:0] s_axi4lite_bresp,
        output logic s_axi4lite_arready,
        input wire s_axi4lite_arvalid,
        input wire [5:0] s_axi4lite_araddr,
        input wire [2:0] s_axi4lite_arprot,
        input wire s_axi4lite_rready,
        output logic s_axi4lite_rvalid,
        output logic [31:0] s_axi4lite_rdata,
        output logic [1:0] s_axi4lite_rresp,

        input my_mod_csr_pkg::my_mod_csr__in_t hw_if_in,
        output my_mod_csr_pkg::my_mod_csr__out_t hw_if_out
    );

    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [5:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_bit_en;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    // Max Outstanding Transactions: 2
    logic [1:0] axi4lite_n_in_flight;
    logic axi4lite_prev_was_rd;
    logic axi4lite_arvalid;
    logic [5:0] axi4lite_araddr;
    logic axi4lite_ar_accept;
    logic axi4lite_awvalid;
    logic [5:0] axi4lite_awaddr;
    logic axi4lite_wvalid;
    logic [31:0] axi4lite_wdata;
    logic [3:0] axi4lite_wstrb;
    logic axi4lite_aw_accept;
    logic axi4lite_resp_acked;

    // Transaction request accpetance
    always_ff @(posedge clk) begin
        if(rst) begin
            axi4lite_prev_was_rd <= '0;
            axi4lite_arvalid <= '0;
            axi4lite_araddr <= '0;
            axi4lite_awvalid <= '0;
            axi4lite_awaddr <= '0;
            axi4lite_wvalid <= '0;
            axi4lite_wdata <= '0;
            axi4lite_wstrb <= '0;
            axi4lite_n_in_flight <= '0;
        end else begin
            // AR* acceptance register
            if(axi4lite_ar_accept) begin
                axi4lite_prev_was_rd <= '1;
                axi4lite_arvalid <= '0;
            end
            if(s_axi4lite_arvalid && s_axi4lite_arready) begin
                axi4lite_arvalid <= '1;
                axi4lite_araddr <= s_axi4lite_araddr;
            end

            // AW* & W* acceptance registers
            if(axi4lite_aw_accept) begin
                axi4lite_prev_was_rd <= '0;
                axi4lite_awvalid <= '0;
                axi4lite_wvalid <= '0;
            end
            if(s_axi4lite_awvalid && s_axi4lite_awready) begin
                axi4lite_awvalid <= '1;
                axi4lite_awaddr <= s_axi4lite_awaddr;
            end
            if(s_axi4lite_wvalid && s_axi4lite_wready) begin
                axi4lite_wvalid <= '1;
                axi4lite_wdata <= s_axi4lite_wdata;
                axi4lite_wstrb <= s_axi4lite_wstrb;
            end

            // Keep track of in-flight transactions
            if((axi4lite_ar_accept || axi4lite_aw_accept) && !axi4lite_resp_acked) begin
                axi4lite_n_in_flight <= axi4lite_n_in_flight + 1'b1;
            end else if(!(axi4lite_ar_accept || axi4lite_aw_accept) && axi4lite_resp_acked) begin
                axi4lite_n_in_flight <= axi4lite_n_in_flight - 1'b1;
            end
        end
    end

    always_comb begin
        s_axi4lite_arready = (!axi4lite_arvalid || axi4lite_ar_accept);
        s_axi4lite_awready = (!axi4lite_awvalid || axi4lite_aw_accept);
        s_axi4lite_wready = (!axi4lite_wvalid || axi4lite_aw_accept);
    end

    // Request dispatch
    always_comb begin
        cpuif_wr_data = axi4lite_wdata;
        for(int i=0; i<4; i++) begin
            cpuif_wr_bit_en[i*8 +: 8] = {8{axi4lite_wstrb[i]}};
        end
        cpuif_req = '0;
        cpuif_req_is_wr = '0;
        cpuif_addr = '0;
        axi4lite_ar_accept = '0;
        axi4lite_aw_accept = '0;

        if(axi4lite_n_in_flight < 2'd2) begin
            // Can safely issue more transactions without overwhelming response buffer
            if(axi4lite_arvalid && !axi4lite_prev_was_rd) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axi4lite_araddr[5:2], 2'b0};
                if(!cpuif_req_stall_rd) axi4lite_ar_accept = '1;
            end else if(axi4lite_awvalid && axi4lite_wvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '1;
                cpuif_addr = {axi4lite_awaddr[5:2], 2'b0};
                if(!cpuif_req_stall_wr) axi4lite_aw_accept = '1;
            end else if(axi4lite_arvalid) begin
                cpuif_req = '1;
                cpuif_req_is_wr = '0;
                cpuif_addr = {axi4lite_araddr[5:2], 2'b0};
                if(!cpuif_req_stall_rd) axi4lite_ar_accept = '1;
            end
        end
    end


    // AXI4-Lite Response Logic
    struct {
        logic is_wr;
        logic err;
        logic [31:0] rdata;
    } axi4lite_resp_buffer[2];

    logic [1:0] axi4lite_resp_wr_ptr;
    logic [1:0] axi4lite_resp_rd_ptr;

    always_ff @(posedge clk) begin
        if(rst) begin
            for(int i=0; i<2; i++) begin
                axi4lite_resp_buffer[i].is_wr <= '0;
                axi4lite_resp_buffer[i].err <= '0;
                axi4lite_resp_buffer[i].rdata <= '0;
            end
            axi4lite_resp_wr_ptr <= '0;
            axi4lite_resp_rd_ptr <= '0;
        end else begin
            // Store responses in buffer until AXI response channel accepts them
            if(cpuif_rd_ack || cpuif_wr_ack) begin
                if(cpuif_rd_ack) begin
                    axi4lite_resp_buffer[axi4lite_resp_wr_ptr[0:0]].is_wr <= '0;
                    axi4lite_resp_buffer[axi4lite_resp_wr_ptr[0:0]].err <= cpuif_rd_err;
                    axi4lite_resp_buffer[axi4lite_resp_wr_ptr[0:0]].rdata <= cpuif_rd_data;

                end else if(cpuif_wr_ack) begin
                    axi4lite_resp_buffer[axi4lite_resp_wr_ptr[0:0]].is_wr <= '1;
                    axi4lite_resp_buffer[axi4lite_resp_wr_ptr[0:0]].err <= cpuif_wr_err;
                end
                axi4lite_resp_wr_ptr <= axi4lite_resp_wr_ptr + 1'b1;
            end

            // Advance read pointer when acknowledged
            if(axi4lite_resp_acked) begin
                axi4lite_resp_rd_ptr <= axi4lite_resp_rd_ptr + 1'b1;
            end
        end
    end

    always_comb begin
        axi4lite_resp_acked = '0;
        s_axi4lite_bvalid = '0;
        s_axi4lite_rvalid = '0;
        if(axi4lite_resp_rd_ptr != axi4lite_resp_wr_ptr) begin
            if(axi4lite_resp_buffer[axi4lite_resp_rd_ptr[0:0]].is_wr) begin
                s_axi4lite_bvalid = '1;
                if(s_axi4lite_bready) axi4lite_resp_acked = '1;
            end else begin
                s_axi4lite_rvalid = '1;
                if(s_axi4lite_rready) axi4lite_resp_acked = '1;
            end
        end

        s_axi4lite_rdata = axi4lite_resp_buffer[axi4lite_resp_rd_ptr[0:0]].rdata;
        if(axi4lite_resp_buffer[axi4lite_resp_rd_ptr[0:0]].err) begin
            s_axi4lite_bresp = 2'b10;
            s_axi4lite_rresp = 2'b10;
        end else begin
            s_axi4lite_bresp = 2'b00;
            s_axi4lite_rresp = 2'b00;
        end
    end

    logic cpuif_req_masked;
    logic external_req;
    logic external_pending;
    logic external_wr_ack;
    logic external_rd_ack;
    always_ff @(posedge clk) begin
        if(rst) begin
            external_pending <= '0;
        end else begin
            if(external_req & ~external_wr_ack & ~external_rd_ack) external_pending <= '1;
            else if(external_wr_ack | external_rd_ack) external_pending <= '0;
            assert(!external_wr_ack || (external_pending | external_req))
                else $error("An external wr_ack strobe was asserted when no external request was active");
            assert(!external_rd_ack || (external_pending | external_req))
                else $error("An external rd_ack strobe was asserted when no external request was active");
        end
    end

    // Read & write latencies are balanced. Stalls not required
    // except if external
    assign cpuif_req_stall_rd = external_pending;
    assign cpuif_req_stall_wr = external_pending;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        logic MY_MOD_VERSION;
        logic PROTECTED_REG;
        logic UNLOCK_PROTECTED_REG;
        logic SINGLE_PULSE;
        logic WRITE_ONCE;
        logic SIMPLE_MEM;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_strb_is_external;

    logic [5:0] decoded_addr;

    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_bit_en;

    always_comb begin
        automatic logic is_external = '0;
        decoded_reg_strb.MY_MOD_VERSION = cpuif_req_masked & (cpuif_addr == 6'h0);
        decoded_reg_strb.PROTECTED_REG = cpuif_req_masked & (cpuif_addr == 6'h4);
        decoded_reg_strb.UNLOCK_PROTECTED_REG = cpuif_req_masked & (cpuif_addr == 6'h8);
        decoded_reg_strb.SINGLE_PULSE = cpuif_req_masked & (cpuif_addr == 6'hc);
        decoded_reg_strb.WRITE_ONCE = cpuif_req_masked & (cpuif_addr == 6'h10);
        decoded_reg_strb.SIMPLE_MEM = cpuif_req_masked & (cpuif_addr >= 6'h20) & (cpuif_addr <= 6'h20 + 6'h1f);
        is_external |= cpuif_req_masked & (cpuif_addr >= 6'h20) & (cpuif_addr <= 6'h20 + 6'h1f);
        decoded_strb_is_external = is_external;
        external_req = is_external;
    end

    // Pass down signals to next stage
    assign decoded_addr = cpuif_addr;

    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_bit_en = cpuif_wr_bit_en;

    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } FIELD;
        } PROTECTED_REG;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } UNLOCK;
        } UNLOCK_PROTECTED_REG;
        struct {
            struct {
                logic next;
                logic load_next;
            } FIELD;
        } SINGLE_PULSE;
        struct {
            struct {
                logic [31:0] next;
                logic load_next;
            } FIELD;
        } WRITE_ONCE;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                logic [31:0] value;
            } FIELD;
        } PROTECTED_REG;
        struct {
            struct {
                logic [31:0] value;
            } UNLOCK;
        } UNLOCK_PROTECTED_REG;
        struct {
            struct {
                logic value;
            } FIELD;
        } SINGLE_PULSE;
        struct {
            struct {
                logic [31:0] value;
            } FIELD;
        } WRITE_ONCE;
    } field_storage_t;
    field_storage_t field_storage;

    // Field: my_mod_csr.PROTECTED_REG.FIELD
    always_comb begin
        automatic logic [31:0] next_c = field_storage.PROTECTED_REG.FIELD.value;
        automatic logic load_next_c = '0;
        if(decoded_reg_strb.PROTECTED_REG && decoded_req_is_wr && &(field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value)) begin // SW write
            next_c = (field_storage.PROTECTED_REG.FIELD.value & ~decoded_wr_bit_en[31:0]) | (decoded_wr_data[31:0] & decoded_wr_bit_en[31:0]);
            load_next_c = '1;
        end
        field_combo.PROTECTED_REG.FIELD.next = next_c;
        field_combo.PROTECTED_REG.FIELD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.PROTECTED_REG.FIELD.value <= 32'h0;
        end else if(field_combo.PROTECTED_REG.FIELD.load_next) begin
            field_storage.PROTECTED_REG.FIELD.value <= field_combo.PROTECTED_REG.FIELD.next;
        end
    end
    assign hw_if_out.PROTECTED_REG.FIELD.value = field_storage.PROTECTED_REG.FIELD.value;
    // Field: my_mod_csr.UNLOCK_PROTECTED_REG.UNLOCK
    always_comb begin
        automatic logic [31:0] next_c = field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value;
        automatic logic load_next_c = '0;
        if(decoded_reg_strb.UNLOCK_PROTECTED_REG && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value & ~decoded_wr_bit_en[31:0]) | (decoded_wr_data[31:0] & decoded_wr_bit_en[31:0]);
            load_next_c = '1;
        end
        field_combo.UNLOCK_PROTECTED_REG.UNLOCK.next = next_c;
        field_combo.UNLOCK_PROTECTED_REG.UNLOCK.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value <= 32'h0;
        end else if(field_combo.UNLOCK_PROTECTED_REG.UNLOCK.load_next) begin
            field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value <= field_combo.UNLOCK_PROTECTED_REG.UNLOCK.next;
        end
    end
    assign hw_if_out.UNLOCK_PROTECTED_REG.UNLOCK.value = field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value;
    // Field: my_mod_csr.SINGLE_PULSE.FIELD
    always_comb begin
        automatic logic [0:0] next_c = field_storage.SINGLE_PULSE.FIELD.value;
        automatic logic load_next_c = '0;
        if(decoded_reg_strb.SINGLE_PULSE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.SINGLE_PULSE.FIELD.value & ~decoded_wr_bit_en[0:0]) | (decoded_wr_data[0:0] & decoded_wr_bit_en[0:0]);
            load_next_c = '1;
        end else begin // singlepulse clears back to 0
            next_c = '0;
            load_next_c = '1;
        end
        field_combo.SINGLE_PULSE.FIELD.next = next_c;
        field_combo.SINGLE_PULSE.FIELD.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.SINGLE_PULSE.FIELD.value <= 1'h0;
        end else if(field_combo.SINGLE_PULSE.FIELD.load_next) begin
            field_storage.SINGLE_PULSE.FIELD.value <= field_combo.SINGLE_PULSE.FIELD.next;
        end
    end
    assign hw_if_out.SINGLE_PULSE.FIELD.value = field_storage.SINGLE_PULSE.FIELD.value;
    // Field: my_mod_csr.WRITE_ONCE.FIELD
    always_comb begin
        automatic logic [31:0] next_c = field_storage.WRITE_ONCE.FIELD.value;
        automatic logic load_next_c = '0;
        if(decoded_reg_strb.WRITE_ONCE && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.WRITE_ONCE.FIELD.value & ~decoded_wr_bit_en[31:0]) | (decoded_wr_data[31:0] & decoded_wr_bit_en[31:0]);
            load_next_c = '1;
        end
        field_combo.WRITE_ONCE.FIELD.next = next_c;
        field_combo.WRITE_ONCE.FIELD.load_next = load_next_c;
    end

    always_ff @(posedge clk) begin
        if(field_combo.WRITE_ONCE.FIELD.load_next) begin
            field_storage.WRITE_ONCE.FIELD.value <= field_combo.WRITE_ONCE.FIELD.next;
        end
    end
    assign hw_if_out.WRITE_ONCE.FIELD.value = field_storage.WRITE_ONCE.FIELD.value;
    assign hw_if_out.SIMPLE_MEM.req = decoded_reg_strb.SIMPLE_MEM;
    assign hw_if_out.SIMPLE_MEM.addr = decoded_addr[5:0];
    assign hw_if_out.SIMPLE_MEM.req_is_wr = decoded_req_is_wr;
    assign hw_if_out.SIMPLE_MEM.wr_data = decoded_wr_data;
    assign hw_if_out.SIMPLE_MEM.wr_bit_en = decoded_wr_bit_en;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    always_comb begin
        automatic logic wr_ack;
        wr_ack = '0;
        wr_ack |= hw_if_in.SIMPLE_MEM.wr_ack;
        external_wr_ack = wr_ack;
    end
    assign cpuif_wr_ack = external_wr_ack | (decoded_req & decoded_req_is_wr & ~decoded_strb_is_external);
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------
    logic readback_external_rd_ack_c;
    always_comb begin
        automatic logic rd_ack;
        rd_ack = '0;
        rd_ack |= hw_if_in.SIMPLE_MEM.rd_ack;
        readback_external_rd_ack_c = rd_ack;
    end

    logic readback_external_rd_ack;

    assign readback_external_rd_ack = readback_external_rd_ack_c;

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[6];
    assign readback_array[0][11:0] = (decoded_reg_strb.MY_MOD_VERSION && !decoded_req_is_wr) ? 12'h567 : '0;
    assign readback_array[0][19:12] = (decoded_reg_strb.MY_MOD_VERSION && !decoded_req_is_wr) ? 8'h34 : '0;
    assign readback_array[0][27:20] = (decoded_reg_strb.MY_MOD_VERSION && !decoded_req_is_wr) ? 8'h12 : '0;
    assign readback_array[0][31:28] = (decoded_reg_strb.MY_MOD_VERSION && !decoded_req_is_wr) ? 4'h0 : '0;
    assign readback_array[1][31:0] = (decoded_reg_strb.PROTECTED_REG && !decoded_req_is_wr) ? field_storage.PROTECTED_REG.FIELD.value : '0;
    assign readback_array[2][31:0] = (decoded_reg_strb.UNLOCK_PROTECTED_REG && !decoded_req_is_wr) ? field_storage.UNLOCK_PROTECTED_REG.UNLOCK.value : '0;
    assign readback_array[3][0:0] = (decoded_reg_strb.SINGLE_PULSE && !decoded_req_is_wr) ? field_storage.SINGLE_PULSE.FIELD.value : '0;
    assign readback_array[3][31:1] = '0;
    assign readback_array[4][31:0] = (decoded_reg_strb.WRITE_ONCE && !decoded_req_is_wr) ? field_storage.WRITE_ONCE.FIELD.value : '0;
    assign readback_array[5] = hw_if_in.SIMPLE_MEM.rd_ack ? hw_if_in.SIMPLE_MEM.rd_data : '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr & ~decoded_strb_is_external;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<6; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign external_rd_ack = readback_external_rd_ack;
    assign cpuif_rd_ack = readback_done | readback_external_rd_ack;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
